#!/usr/bin/env bash

# Load default variables from the user config
CONFIG_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/yasm/config"
[[ -f "$CONFIG_FILE" ]] && source "$CONFIG_FILE"

# User configurable variables
DOT_SCRIPTS_DIR="${yasm_scripts_dir:-$HOME/.dotscripts/scripts}" # Folder where scripts will be stored
DOT_META_DIR="${yasm_meta_dir:-$HOME/.dotscripts/meta}"          # Folder where metadata will be stored
YASM_EDITOR="${yasm_editor:-${EDITOR:-nano}}"                    # Defaul Editor used by yasm

# Global options for fzf
FZF_OPTS=(
  --height=30%
  --border=rounded
  --margin=0,0,1,3
  --layout=reverse
  --ansi
)

# generate_meta_template - Outputs a boilerplate TOML metadata block for a script.
#
# Arguments:
#   $1 - Script name (used in the usage field).
#
# Output:
#   Prints a TOML-formatted metadata template with placeholder fields:
#     - description
#     - tags
#     - usage (includes the script name)
#     - dependencies
function generate_meta_template() {
  local name="$1"
  cat <<EOF
description = "Add a description here"
tags = ["add", "tags", "here"]
usage = "$name.sh <arguments>"
dependencies = ["add", "dependencies", "here"]
EOF
}

# generate_script_template - Outputs a basic Bash script template with a greeting.
#
# Arguments:
#   $1 - Script name
#
# Output:
#   Prints a simple Bash script with:
#     - A hello message using the script name
function generate_script_template() {
  local name="$1"
  cat <<EOF
#!/usr/bin/env bash

# $name script
echo "Hello from $name!"
EOF
}

# check_installed - Verifies if the given commands are available on the system.
#
# Arguments:
#   $@ - List of command names to check.
#
# Output:
#   - If any commands are missing, prints them as a space-separated list.
#
# Returns:
#   0 - All commands are installed.
#   1 - One or more commands are missing.
function check_installed() {
  local missing=()
  for dep in "$@"; do
    if ! command -v "$dep" &>/dev/null; then
      missing+=("$dep") # Add missing dependency to the list
    fi
  done

  # Return the missing dependencies as a string
  if [ ${#missing[@]} -gt 0 ]; then
    echo "${missing[@]}" # Return the missing dependencies as a space-separated list
    return 1             # Return 1 to indicate missing dependencies
  fi

  return 0 # Return 0 if no dependencies are missing
}

# create_script - Interactive utility to create a new script and metadata file.
#
# Arguments:
#   $1 - (Optional) Name of the script. If not provided, user will be prompted.
#
# Behavior:
#   - Validates the script name (alphanumeric, underscores, hyphens).
#   - Prevents overwriting existing script or metadata files.
#   - Generates a script in $DOT_SCRIPTS_DIR and metadata in $DOT_META_DIR.
#   - Makes the script executable.
#   - Optionally opens the files in the user's editor.
#
# Dependencies:
#   - Relies on generate_script_template and generate_meta_template functions.
#   - Uses $YASM_EDITOR for editing, or falls back to nano if undefined.
function create_script() {
  # Try to get name from the first argument
  name="$1"

  # Prompt user for a new script name if argument was not provided
  if [[ -z "$name" ]]; then
    echo -n "󰛿 Enter script name: "
    read -r name
  fi

  # Exit if no name was not entered
  [[ -z "$name" ]] && echo " No name entered. Script creation cancelled." && return

  # Exit if name is not valid
  [[ ! "$name" =~ ^[a-zA-Z0-9_-]+$ ]] && echo " Invalid name. Only alphanumeric, hyphens (-), and underscores (_) are allowed." && return

  local script_path="$DOT_SCRIPTS_DIR/$name.sh"
  local meta_path="$DOT_META_DIR/$name.toml"

  # Exit if script or metadata already exists
  [[ -f "$script_path" ]] && echo " Script for '$name' already exists." && return
  [[ -f "$meta_path" ]] && echo " Metadata for '$name' already exists." && return

  # Create the script and metadata files
  generate_script_template "$name" >"$script_path"
  generate_meta_template "$name" >"$meta_path"

  # Make the script executable
  chmod +x "$script_path"

  # Confirmation message
  echo " Script '$name' created!"
  echo "  - Script: $script_path"
  echo "  - Metadata: $meta_path"

  # Prompt user to open files in editor
  read -rp " Open files in editor($YASM_EDITOR)? [Y/n]: " open_choice

  # Convert to lowercase
  open_choice=$(echo "$open_choice" | tr '[:upper:]' '[:lower:]')

  # If user said yes open it in $YASM_EDITOR
  if [[ -z "$open_choice" || "$open_choice" == "y" || "$open_choice" == "yes" ]]; then
    $YASM_EDITOR "$script_path" "$meta_path"
  fi
}

# rename_script - Renames an existing script and its associated metadata file.
#
# Arguments:
#   $1 - Current name of the script (without .sh extension).
#
# Behavior:
#   - Prompts the user for a new name.
#   - Validates the new name format (alphanumeric, hyphens, underscores).
#   - Renames both script and metadata files in their respective directories.
#   - Updates the 'name' and 'usage' fields inside the metadata file.
#
# Output:
#   - Error messages for invalid input or conflicts.
#   - Success message upon successful rename.
#
# Dependencies:
#   - Requires $DOT_SCRIPTS_DIR and $DOT_META_DIR to be set.
#   - Uses `sed` for in-place editing of metadata (BSD-compatible syntax expected).
function rename_script() {
  local old_name="$1"
  local old_script="$DOT_SCRIPTS_DIR/$old_name.sh"
  local old_meta="$DOT_META_DIR/$old_name.toml"

  # Exit if the old script or metadata file doesn't exist
  [[ ! -f "$old_script" ]] && echo " Script for '$old_name' not found." && return
  [[ ! -f "$old_meta" ]] && echo " Metadata for '$old_name' not found." && return

  # Take the new name for  script from user
  echo -n "󰚰 Enter the new name: "
  read -r new_name

  # Exit if a new name wasn't entered
  [[ -z "$new_name" ]] && echo " No new name entered. Rename cancelled." && return

  # Exit if the new name is not valid
  [[ ! "$new_name" =~ ^[a-zA-Z0-9_-]+$ ]] && echo " Invalid name. Only alphanumeric, hyphens (-), and underscores (_) are allowed." && return

  local new_script="$DOT_SCRIPTS_DIR/$new_name.sh"
  local new_meta="$DOT_META_DIR/$new_name.toml"

  # Exit if the new script or metadata file already exists
  [[ -e "$new_script" ]] && echo " Script for $new_name already exists." && return
  [[ -e "$new_meta" ]] && echo " Metadata for $new_name already exists." && return

  # Rename files
  mv "$old_script" "$new_script"
  mv "$old_meta" "$new_meta"

  # Update metadata
  sed -i '' "s/^name = \".*\"/name = \"$new_name\"/" "$new_meta"
  sed -i '' "s/^usage = \".*\"/usage = \"$new_name.sh <arguments>\"/" "$new_meta"

  # Show confirmation message
  echo " Script renamed from '$old_name' to '$new_name'."
}

# update_script - Opens a script and its metadata for editing.
#
# Arguments:
#   $1 - Script name (without .sh extension).
#
# Behavior:
#   - Verifies the existence of both the script and its metadata.
#   - Opens both files in the user's preferred editor.
#
# Output:
#   - Error messages if files are missing.
#
# Dependencies:
#   - Requires $DOT_SCRIPTS_DIR and $DOT_META_DIR to be set.
#   - Uses $YASM_EDITOR
function update_script() {
  local name="$1"
  local script_path="$DOT_SCRIPTS_DIR/$name.sh"
  local meta_path="$DOT_META_DIR/$name.toml"

  # Exit if the script or metadata file doesn't exist
  [[ ! -f "$script_path" ]] && echo " Script for '$name' not found." && return
  [[ ! -f "$meta_path" ]] && echo " Metadata for '$name' not found." && return

  # Open the script and metadata files in the editor
  $YASM_EDITOR "$script_path" "$meta_path"
}

# delete_script - Deletes a script and its associated metadata after confirmation.
#
# Arguments:
#   $1 - Script name (without .sh extension).
#
# Behavior:
#   - Checks if both the script and its metadata exist.
#   - Prompts the user for confirmation before deletion.
#   - Deletes both files if confirmed.
#
# Output:
#   - Confirmation prompt and success or cancellation message.
#   - Error messages if files are missing.
#
# Dependencies:
#   - Requires $DOT_SCRIPTS_DIR and $DOT_META_DIR to be set.
#   - Uses 'rm' for file deletion.
function delete_script() {
  local name="$1"
  local script_path="$DOT_SCRIPTS_DIR/$name.sh"
  local meta_path="$DOT_META_DIR/$name.toml"

  # Exit if the script or metadata for file doesn't exist
  [[ ! -f "$script_path" ]] && echo " Script for '$name' not found." && return
  [[ ! -f "$meta_path" ]] && echo " Metadata for '$name' not found." && return

  # Confirm deletion
  echo -n " Are you sure you want to delete '$name'? (y/N): "
  read -r confirm

  # If user said yes delete it
  if [[ "$confirm" == "y" ]]; then
    rm -f "$script_path" "$meta_path"                           # Delete the script and metadata
    echo " Script '$name' and its metadata have been deleted." # Show confirmation message
  else
    echo " Deletion cancelled."
  fi
}

# run_script - Executes a user script after checking its metadata and dependencies.
#
# Arguments:
#   $1 - Script name (without .sh extension).
#
# Behavior:
#   - Verifies that the script exists and is executable.
#   - Loads associated metadata and extracts dependencies and usage info.
#   - Checks for missing dependencies using check_installed.
#   - Prompts the user for arguments and executes the script.
#
# Output:
#   - Usage information.
#   - Warnings for missing scripts, metadata, or dependencies.
#   - Runs the script with user-provided arguments.
#
# Dependencies:
#   - Requires $DOT_SCRIPTS_DIR and $DOT_META_DIR to be set.
#   - Expects a valid TOML-formatted metadata file.
#   - Uses check_installed function to validate dependencies.
function run_script() {
  local name="$1"
  local script_path="$DOT_SCRIPTS_DIR/$name.sh"
  local meta_path="$DOT_META_DIR/$name.toml"

  # Exit if the script is not executable or doesn't exist
  [[ ! -x "$script_path" ]] && echo " Script for '$name' not found or not executable at: $script_path" && return

  # Exit if the metadata file doesn't exist
  [[ ! -f "$meta_path" ]] && echo " Metadata for '$name' not found at: $meta_path" && return

  # Check for dependencies in the metadata file
  if [[ -f "$meta_path" ]]; then
    # Extract dependencies from the metadata file
    local deps
    deps=$(grep '^dependencies' "$meta_path" | cut -d'[' -f2 | cut -d']' -f1 | tr ',' '\n' | tr -d '" ')

    if [[ -n "$deps" ]]; then
      # Capture the missing dependencies
      missing_deps=$(check_installed $deps)

      # If there are missing dependencies, return and don't run the script
      if [[ -n "$missing_deps" ]]; then
        echo " Missing dependencies: $missing_deps"
        return 1
      fi
    fi
  fi

  # Display usage information from metadata
  local usage
  usage=$(grep '^usage' "$meta_path" | cut -d'"' -f2)
  echo -e " Usage: $usage"

  # Prompt for arguments
  read -rp "󰛿 Enter arguments for '$name': " args
  echo " Running: $name $args"
  echo

  # Execute the script with the provided arguments
  "$script_path" $args
}

# show_help - Display usage instructions for the YASM CLI tool.
#
# Description:
#   Prints an overview of available YASM commands and their usage.
#   Helpful for users to understand how to interact with the tool.
#
# Output:
#   - A list of available commands with a brief description.
#   - An example of how to use a command.
function show_help() {
  echo "🛠️ YASM - Usage"
  echo
  echo "  yasm                   Launch fuzzy menu"
  echo "  yasm create            Create a new script interactively"
  echo "  yasm help              Show this help message"
  echo "  yasm run               Pick a script via menu and run it"
  echo "  yasm run <script>      Run a specific script directly"
  echo "  yasm update            Pick a script via menu and update it"
  echo "  yasm update <script>   Update a specific script directly"
  echo "  yasm rename            Pick a script via menu and rename it"
  echo "  yasm rename <script>   Rename a specific script directly"
  echo "  yasm delete            Pick a script via menu and delete it"
  echo "  yasm delete <script>   Delete a specific script directly"
  echo "  yasm config            Show available config options"
  echo "  yasm config edit       Open config file in editor"
  echo
  echo "Example:"
  echo "  yasm run backup"
}

# show_config_options - Display help information about configuration options.
#
# Description:
#   Prints an explanation of the supported configuration keys for YASM.
#   Useful for users who want to understand how to customize the behavior of the tool via the config file.
#
# Configuration Keys:
#   - yasm_scripts_dir : Directory where the script `.sh` files are stored.
#   - yasm_meta_dir    : Directory where the corresponding metadata `.toml` files are stored.
#   - yasm_editor      : Editor used to open and edit script and metadata files.
function show_config_options() {
  echo " YASM - Config"
  echo
  echo "  yasm_scripts_dir      Directory in which shell files of scripts are stored"
  echo "  yasm_meta_dir         Directory in which metadata files of scripts are stored"
  echo "  yasm_editor           Editor to use for opening scripts and metadata files"
}

# edit_config - Open the DotScripts config file in the preferred editor.
#
# Description:
#   Opens the user’s configuration file in the editor specified by the 'yasm_editor' config key.
#   If the config file does not exist, it creates an empty file and its parent directory if needed.
#
# Dependencies:
#   - CONFIG_FILE   : Path to the config file.
#   - Uses $YASM_EDITOR
function edit_config() {
  local file="$CONFIG_FILE"

  # Create the file if it doesn't exist
  if [[ ! -f "$file" ]]; then
    mkdir -p "$(dirname "$file")" # Ensure the parent directory exists
    touch "$file"
  fi

  # Open the config file in the preferred editor
  "$YASM_EDITOR" "$file"
}

# fzf_list_scripts - List and select scripts interactively using fzf.
#
# Description:
#   This function uses fzf to provide an interactive list of scripts stored in the metadata directory ($DOT_META_DIR).
#   It shows each script's name and description, allowing the user to select a script.
#   Returns the selected script's name.
#
# Behavior:
#   - Lists scripts by reading .toml metadata files from $DOT_META_DIR.
#   - Displays each script's name and description in a fuzzy search prompt.
#   - Returns the script name of the selected script.
#
# Output:
#   - Returns the name of the selected script (or prints an error message if no scripts are found).
#   - If no scripts are found in the metadata directory, it returns 1 and outputs an error message.
#
# Dependencies:
#   - Requires fzf for interactive search.
#   - Requires DOT_META_DIR to be set and contain .toml metadata files.
function fzf_list_scripts() {
  local choice
  local script_name

  # Ensure that the DOT_META_DIR is not empty
  shopt -s nullglob
  local toml_files=("$DOT_META_DIR"/*.toml)
  shopt -u nullglob

  if [[ ${#toml_files[@]} -eq 0 ]]; then
    echo "No scripts found." >&2
    return 1
  fi

  # Generate list of scripts with descriptions
  choice=$(
    for file in "$DOT_META_DIR"/*.toml; do
      name=$(basename "$file" .toml)
      desc=$(grep -m1 description "$file" | cut -d'"' -f2)
      printf "%-20s - %s\n" "$name" "$desc"
    done | fzf --prompt=" Select script: " "${FZF_OPTS[@]}"
  )

  # Extract the script name from the selection
  script_name=$(echo "$choice" | awk '{print $1}') # We are only using the fist part before space as filename is expected to be one word

  # Returning the script name
  echo $script_name
}

# fzf_menu - Display a fuzzy menu to select an action for managing scripts.
#
# Description:
#   This function presents the user with a menu of actions that can be performed on scripts, such as running,
#   creating, updating, renaming, or deleting scripts. It uses `fzf` for an interactive selection process.
#   The user can also view the help message for the available options.
#
# Behavior:
#   - The function displays a list of options in the terminal using `fzf`.
#   - Based on the user's selection, it either runs the appropriate script management function (e.g., `create_script`,
#     `run_script`, `update_script`, `rename_script`, `delete_script`, or `show_help`).
#   - It also handles invalid or unselected choices with a fallback message.
#
# Output:
#   - If a valid action is selected, the corresponding function is executed.
#   - If no script is selected (when required), an error message is displayed.
#   - If an invalid or no option is selected, the menu will display a message indicating that no action was taken.
#
# Dependencies:
#   - Requires `fzf` for displaying the interactive menu.
#   - Requires functions like `fzf_list_scripts`, `run_script`, `create_script`, `update_script`, `rename_script`,
#     `delete_script`, and `show_help` to handle the selected actions.
function fzf_menu() {
  local choice
  local options=(
    "1. Run Script"
    "2. Create Script"
    "3. Update Script"
    "4. Rename Script"
    "5. Delete Script"
    "6. Show Help"
    "7. Show Config Options"
    "8. Edit Config"
  )

  # Display options using fzf with newline-separated entries
  choice=$(printf "%s\n" "${options[@]}" |
    fzf --prompt=" Select action: " "${FZF_OPTS[@]}")

  # Handle the user's selection
  case "$choice" in
  "${options[0]}") # Run Script
    script_name=$(fzf_list_scripts)
    [ -z "$script_name" ] && echo "No script selected" || run_script "$script_name"
    ;;
  "${options[1]}") # Create Script
    create_script
    ;;
  "${options[2]}") # Update Script
    script_name=$(fzf_list_scripts)
    [ -z "$script_name" ] && echo "No script selected" || update_script "$script_name"
    ;;
  "${options[3]}") # Rename Script
    script_name=$(fzf_list_scripts)
    [ -z "$script_name" ] && echo "No script selected" || rename_script "$script_name"
    ;;
  "${options[4]}") # Delete Script
    script_name=$(fzf_list_scripts)
    [ -z "$script_name" ] && echo "No script selected" || delete_script "$script_name"
    ;;
  "${options[5]}") # Delete Script
    show_help
    ;;
  "${options[6]}") # Delete Script
    show_config_options
    ;;
  "${options[7]}") # Delete Script
    edit_config
    ;;
  *)
    echo "No action selected."
    ;;
  esac
}

#  handler - handler function to handle user actions and execute the corresponding operations.
#
# Arguments:
#   $1: Action to be performed (e.g., "run", "new", "help", "rename", "update", "delete").
#   $2: Optional script name for specific actions like "run", "rename", "update", or "delete".
#
# Description:
#   This function processes the provided action and executes the corresponding operation based on the arguments passed.
#   If no action is provided, it launches the `fzf_menu` for user interaction.
#   If an invalid action is provided, it displays an error message with guidance on how to get help.
#
#   The available actions are:
#     - 'create': Creates a new script interactively.
#     - 'help': Displays help information.
#     - 'run': Runs a specified script or prompts the user to select one.
#     - 'rename': Renames a specified script or prompts the user to select one.
#     - 'update': Updates a specified script or prompts the user to select one.
#     - 'delete': Deletes a specified script or prompts the user to select one.
#     - 'config': Displays available configuration options or opens the config file in the editor.
#
# Example:
#   handler "run" "backup"       # Runs the 'backup' script.
#   handler "create"                # Creates a new script interactively.
#   handler "help"               # Displays help information.
#   handler "run"                # Prompts the user to select a script to run.
#   handler "delete" "backup"    # Deletes the 'backup' script.
#
# Notes:
#   - If no script name is provided with actions like 'run', 'rename', 'update', or 'delete', the function will prompt the user to select a script using the `fzf` fuzzy finder.
#   - If an invalid action is passed, the function will display an error message and recommend using the `yasm help` command for guidance.
function handler() {
  local action="$1"
  local value="$2"

  if [[ -z "$action" ]]; then
    fzf_menu

  elif [[ "$action" == "create" ]]; then
    create_script "$value"

  elif [[ "$action" == "help" ]]; then
    show_help

  elif [[ "$action" == "run" ]]; then
    if [[ -z "$value" ]]; then
      selected_script=$(fzf_list_scripts)
      [[ -z "$selected_script" ]] && echo "No script selected" || run_script "$selected_script"
    else
      run_script "$value"
    fi

  elif [[ "$action" == "rename" ]]; then
    if [[ -z "$value" ]]; then
      script_name=$(fzf_list_scripts)
      [[ -z "$script_name" ]] && echo "No script selected" || rename_script "$script_name"
    else
      rename_script "$value"
    fi

  elif [[ "$action" == "update" ]]; then
    if [[ -z "$value" ]]; then
      script_name=$(fzf_list_scripts)
      [[ -z "$script_name" ]] && echo "No script selected" || update_script "$script_name"
    else
      update_script "$value"
    fi

  elif [[ "$action" == "delete" ]]; then
    if [[ -z "$value" ]]; then
      script_name=$(fzf_list_scripts)
      [[ -z "$script_name" ]] && echo "No script selected" || delete_script "$script_name"
    else
      delete_script "$value"
    fi

  elif [[ "$action" == "config" ]]; then
    if [[ -z "$value" ]]; then
      show_config_options
    elif [[ "$value" == "edit" ]]; then
      edit_config
    else
      echo " Invalid option: 'config $value'"
      echo "Run 'yasm config' to see available options."
    fi

  else
    echo " Invalid command: '$action'"
    echo "Run 'yasm help' to see available commands."
  fi
}

function main() {
  # Ensure required directories exist
  mkdir -p "$DOT_META_DIR" "$DOT_SCRIPTS_DIR"

  # Call the main handler function
  handler "$@"
}

main "$@"
